use strict;
use warnings;
use utf8;
use 5.14.0;

my $VERSION    = 3.2;
my $URL_FORMAT = "http://geohex.net/testcase/hex_v${VERSION}_test_%s.json";
my %CASES = (
    XY2HEX    => 'xt/01_xy2hex.t',
    code2HEX  => 'xt/02_code2hex.t',
    code2XY   => 'xt/03_code2xy.t',
    coord2HEX => 'xt/04_coord2hex.t',
    coord2XY  => 'xt/05_coord2xy.t',
);

use File::Basename qw/dirname/;
use File::Temp qw/tempdir/;
use File::Spec;
use HTTP::Tiny;
use JSON::PP;

main();

sub main {
    my $basedir = File::Spec->catdir(dirname(__FILE__), '..');
    my $tmpdir  = tempdir(CLEANUP => 1);

    # download
    my $ua = HTTP::Tiny->new;
    for my $case (keys %CASES) {
        my $url = sprintf $URL_FORMAT, $case;
        print STDERR "Download: $url\n";

        my $path = File::Spec->catfile($tmpdir, "$case.json");
        my $res = $ua->mirror($url, $path);
        die "Failed: $res->{reason}" unless $res->{success};
    }

    # parse & generate
    my $json = JSON::PP->new;
    for my $case (keys %CASES) {
        my $testdata = $json->decode(do {
            my $path = File::Spec->catfile($tmpdir, "$case.json");
            print STDERR "Parse: $path\n";
            open my $fh, '<', $path or die $!;
            local $/;
            <$fh>
        });
        my $subname = "gen_$case";
        my @cases   = __PACKAGE__->can($subname)->($testdata);
        my $src     = join "\n", @cases;
        my $tests   = scalar @cases;

        my $path = File::Spec->catfile($basedir, $CASES{$case});
        print STDERR "Output: $path\n";
        open my $fh, '>', $path or die $!;
        print $fh <<"EOD";
use strict;
use warnings FATAL => 'all';
use Test::More tests => $tests;
use Geo::Hex::V3;

## This code is generated by $0 ##
## DO *NOT* EDIT IT DIRECTRY    ##

$src
EOD
    }

}

sub gen_XY2HEX {
    my $testdata = shift;

    my @src;
    for my $row (@$testdata) {
        my ($level, $x, $y, $geohex) = @$row;
        push @src => qq{is(Geo::Hex::V3::latlng2zone(Geo::Hex::V3::_xy2loc($x, $y), $level)->{code}, "$geohex", "x:$x,y:$y,level:$level: $geohex");};
    }
    return @src;
}

sub gen_code2HEX {
    my $testdata = shift;

    my @src;
    for my $row (@$testdata) {
        my ($geohex, $lat, $lon) = @$row;
        push @src => qq{is_deeply([\@{Geo::Hex::V3::geohex2zone("$geohex")}{qw/lat lon/}], [$lat, $lon], "$geohex: lat:$lat,lon:$lon");};
    }
    return @src;
}

sub gen_code2XY {
    my $testdata = shift;

    my @src;
    for my $row (@$testdata) {
        my ($geohex, $x, $y) = @$row;
        push @src => qq{is_deeply([\@{Geo::Hex::V3::geohex2zone("$geohex")}{qw/x y/}], [$x, $y], "$geohex: x:$x,y:$y");};
    }

    return @src;
}

sub gen_coord2HEX {
    my $testdata = shift;

    my @src;
    for my $row (@$testdata) {
        my ($level, $lat, $lon, $geohex) = @$row;
        push @src => qq{is(Geo::Hex::V3::latlng2geohex($lat, $lon, $level), "$geohex", "lat:$lat,lon:$lon,level:$level: $geohex");};
    }

    return @src;
}

sub gen_coord2XY {
    my $testdata = shift;

    my @src;
    for my $row (@$testdata) {
        my ($level, $lat, $lon, $x, $y) = @$row;
        push @src => qq{is_deeply([\@{Geo::Hex::V3::latlng2geohex($lat, $lon, $level)}{qw/x y/}], [$x, $y], "lat:$lat,lon:$lon,level:$level: x:$x,y:$y");};
    }

    return @src;
}
